---
title: JVM面试题Part1
date: 2021-07-10 21:11:48
toc: true #是否显示文章目录
categories: "面试题" #分类
tags:   #标签
	- JAVA
---
### 1. JVM内存描述？
程序计数器，VM栈，本地栈和堆，metaspace(方法区)。

**程序计数器**，> 是一块较小的内存空间，当前线程执行的字节码的行号指示器。
字节码解释器工作时就是能过改变这个计数器的值来获取下一条要执行的字节码指令，
分支，循环，跳转和异常的处理，线程恢复等基础功能都要依赖这个计数器完成。

它是JVM规范中规定的唯一没有内存溢出情况的区域。

**VM栈**  虚拟机栈描述的是JAVA方法执行的内存模型，每一个方法在执行的同时都会
创建一个栈用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
它有两种溢出的可能:
1. 栈溢出:线程请求的的栈深度大于虚拟机所允许的深度。例如递归循环终止条件不正确的设计。
2. 内存溢出:虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出oom异常。

**本地栈** 为执行本地方法服务，也会有上述两种溢出情况。

**方法区（metaspace)**: 类的信息，常量池，静态变量，JIT编译后的代码数据。
它有一个别名叫NonHeap.如果内存不够，也会抛出OOM异常

**堆**: 用于存放对象实例，所有的对象实例和数组都要在堆上分配，但由于逃逸分析技术等的发展，
现在也不绝对。

垃圾收集器管理的主要区域就是堆。为了更快更好地收集，现在多是分代处理机制。
有新生代和老年代，新生代又分为(eden空间，from survivor, to surfvivor)。
新生代和老年代采用不同的垃圾收集算法。
如果没有足够的内存来分配实例 ，并且也无法扩展时，会抛出OOM异常。

**直接内存** java从1.4开始引入了NIO，使用channel,buffer的IO方式，可以使用native的函数直接
分配堆外内存，然后通过存储在java堆中的directbytebuffer对象作为这块内存的引用进行操作。
在一些场景中可以提高性能，因为避免了在java堆和native堆中来回复制这些数据。
这块区域如果内存不够也会抛出OOMError的异常。

### 2. 对象的创建  
> 请描述下java中对象创建的过程？
使用new关键字加上对象名，可以创建对象实例。
对于new指令，首先检查指令参数（类名）是否在常量池中，如果可以在常量池中定位一个符号引用，
检查这个符号引用代表的类是否已经加载解析和初始化过，如果没有，则需要加载校验初始化这个类。
然后就是分配内存，对象所需要的内存大小在类加载完成后就可以完全确定。

> jvm如何知道堆中哪些块是free的呢？
使用serial,parnew等带有compact算法的收集器时，系统采用的分配方式是指针碰撞，而使用
CMS这种标记清除算法的收集器时，通常采用空闲列表（记录哪些块是空闲的）。
内存分配的这个操作也不是线程安全的，如何实现的呢？
jvm使用CAS配上失败重试的方式保证操作的原子性。
另一种内存分配动作按照线程划分在不同的空间之中进行，即每一个线程在Java堆中分配一小块内存，称为
本地线程缓冲（TLAB).只有TLAB用完了，才需要同步锁定。虚拟机是否使用TLAB，可以使用参数
-XX:+/-UseTLAB来设定。
内存分配完成后，JVM会把分配的空间都初始化成零值（不包含对象头）。
然后对对象进行必要的设置，如这个对象是哪个类的实例，对象的hashcode,gc分类信息，锁信息，这些配置
都在对象头中。
然后会调用类中的init方法。（静态方法优先执行）

对象在内存中存储的布局有三个区域：对象头，实例数据和对象填充。
对象头还有一个类型指针，即对象指向它的类元数据的指针，标明这个对象是哪个类的实例。
由于hotspot的JVM自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以当
对象实例数据部分没有对齐时，就需要通过对齐填充来补全。
对象的访问定位，我们需要使用栈上的reference来定位堆上的实例数据。
对象访问方式取决于JVM的实现，目前主流的访问方式有句柄和直接指针两种。
直接指针的方式栈中存储的就是对象的地址，直接快速，但是GC操作后如果移动了对象就需要更新这个地址。
Hotspot JVM是使用这种方式来访问对象的。

### 3. 垃圾回收算法
> 如何判断哪些对象该被回收？
采用可达性分析的方式，从GC Roots出发，向下搜索，所走过的路径称为引用链，当一个对象到GC Roots之间
没有引用链时，就确定该对象是不可用的。

Java中，可作为`GC Roots`的对象有下面几种：
* 虚拟机栈中引用的对象
* 方法区(metaspace)中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI引用的对象

> **垃圾收集算法**
1. 标记清除算法 缺点：效率低，会产生空间碎片。
2. 复制算法 ：追求高效，IBM研究表明，很多新生对象存活的时间很短，所以现在新生代中Eden和Survivor（from,to)
分的比例是8:1,所以每次新生代的空间使用率是90%，只有10%是浪费的。当Survivor空间不够用的，需要依赖老年代的内存。
3. 标记整理算法 ： 老年代中的对象存活的时间长，不能采用复制算法。标记整理算法的标记和标记清除一样，然后让存活的对象
向都向一端移动，然后直接清理掉端边界以外的内存。
4. 分代算法
为了提高效率，根据对象生存周期划分成新生代和老年代，针对不同特点采用不同的算法。
新生代使用复制算法，老年代使用标记整理或标记清除算法。
> GC为什么需要stop the world？
可达性分析执行时，如果不stw,则无法保证扫描结果的正确性。
> 当进入GC时，线程会怎么办？
在方法调用，循环跳转，异常跳转等地方设置安全点。
在代码中不会发生引用变化的地方，称为安全区域。
在安全点设置中断标记，如果为真，则线程主动中断挂起。
在线程离开安全区域的时候，检查gc roots是否检查完成，如果没有，则等待。

### 4. 垃圾收集器
1. **Serial收集器**
> 单线程完成收集，要求STW。仍然是client模式下新生代的默认配置。
2. **ParNew收集器**
ParNew收集器是Serial收集器的多线程版本。它也是现在Server模式下首先的新生代收集器。
是因为老年代现在多是选用CMS收集器，而只有ParNew/Serial才可以和它搭配使用。

3. **Parallel Scavenge收集器** 
目标是达到一个可控制的吞吐量（即用户线程运行时间/(GC时间+用户线程运行时间);
CMS目标是达到较短的停顿时间，适合需要与用户交互的程序，给用户良好的体验。
而高吞吐量可以高效地使用cpu的时间，尽快完成程序的运算任务，主要适合在后台运算而不需要
太多交互的任务。
-XX:MaxGCPauseMills：最大GC停顿时间
-XX:GCTimeRatio:GC时间占比

4. **Serial old收集器**
 单线程收集器，标记整理算法，主要意义也是给Client模式下的JVM使用。
它可以作为CMS收集器的后备预案。

5. **Parallel old收集器**
是parallel scavenge收集器的老年代版本，使用多线程和标记整理算法。

6. **CMS收集器** 
目标是获取最短回收停顿时间。
运作过程分为四个步骤：
> 初始标记->并发标记->重新标记->并发清除
**初始标记**仅是标记和GC Roots 能直接关联到的对象。
**重新标记**：为了修正并发标记期间因为用户程序继续运作而导致标记产生变动的那一部分。
由于整个过程中耗时最长的并发标记和并发清除过程收集器和用户线程都可以一起工作，
总体来说它停顿时间比较短。
它的缺点：
1. 对CPU资源比较敏感 大于4个的情况下，使用25%的CPU资源。
2. CMS收集器无法处理浮动垃圾，可能会出现Concurrent mode failure 失败而导致一次
FullGC的产生。
jdk1.6开始，CMS收集器的启动的阈值是92%， 要是CMS运行期间预留的内存无法满足程序需要，
就会出现concurrent mode failure,这时就会使用serial old来进行老年代的垃圾收集。
3. 空间碎片过多时，就会给大对象的分配带来困难，往往出现老年代还有很大的空余，但是没有足够大
的连续的空间来分配给当前对象，不得不提前触发一次FULL GC的产生。

