---
title: JVM面试题Part2
date: 2021-07-11
comments: true #是否可评论
toc: true #是否显示文章目录
categories: "面试题" #分类
tags:   #标签
    - JAVA
---
### 垃圾收集器
> 谈谈你对G1的理解？
G1的目标是替换掉CMS。和CMS有很多共同点。
使用G1收集器，JAVA堆被划分成多个大小相等的独立的Region.
保留了新生代和老年代，它们都是一部分Region的集合。

G1收集器号称可以建立可预测的停顿时间模型，因为它可以有计划地避免在整个java堆中进行全区域
的垃圾收集，G1跟踪各个Region里面的垃圾堆积的价大小（回收所得的空间与所需时间的经验值），
在后台维护一个优先列表，每次根据允许的收集时间，优先收集价值大的Region,这也是Garbage First
的来由。
使用Region划分内存以及优先级的区域回收方式，保证了它可以在有限的时间内可以获取高的收集效率。
> G1是如何避免全堆扫描的？ 就是某Region中的对象，在其他Region中可能会有引用的情况下。
它使用Remembered Set来避免全堆扫描。G1的每一个Region都有一个与之对应的Remember Set,
JVM发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier 暂时中断写操作，
检查Reference引用的对象是否在不同的Region之中，如果是，则通过CardTable把相关引用信息记录到
被引用对象的所属对象的Remember Set之中，当进行内存回收时，GC的根点节的枚举范围加入Remembered set，
可保证不对全堆扫描也不会有遗漏。

G1收集器的运作大致可以划分为以下几个步骤：
1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收
不同于CMS之处是，它的筛选回收是stop the world的，但其实是可以和用户线程一起工作的，但是为了更好地
控制收集时间，而且停顿用户线程可极大地提高收集效率。

Java8在Server模式下模认的垃圾回收器是什么？kafka,spark他们运行的默认收集器是什么配置？
>  java -XX:+PrintCommandLineFlags -version 
   查看输出，你可以发现-XX:+UseParallelGC,在深入理解Java虚拟机中有描述，这代表着新生代使用的是Parallel
   scavenge加老年代使用的Serial Old的收集器组合进行内存回收。
   这也是Server模式下默认的配置。

### JVM类加载机制
1. 如果一个类中有一行代码：
   ```java``` public static int value=123;
   则这个类被加载后，它的value属性是多少？
   在加载验证准备阶段过后，它的值是0，而不是123，因为这个时候未执行任何java方法，而把value赋值为123的putstatic指令
   是在程序被编译后，放到类的构造类<clinit>()方法之中，所以这个动作只有在初始化阶段才会执行。
   但是被final,constant修饰的值因为在编译阶段就会被替换成常量，与这种情况不同。
   类加载中的解析是指JVM将常量池内的符号引用替换为直接引用的过程。
   常量池中有常量（字面量）和符号引用，符号引用常见的有：类和接口的全限定名，字段的名称和描述符以及方法的名称和描述符。
   Java代码编译之后没有像C++的链接过程，它是在JVM加载class文件时候进行动态链接的，也就是说，在class文件中不会保存
   各个方法字段的最终内存布局信息，因此需要在类创建时翻译到具体的内存地址之中。

2. 讲一下你理解的类初始化情况？
   初始化阶段就是执行类构造器<clinit>()方法的过程。
   * <clinit>()方法是由编译器自动收集类中所有变量的赋值动作和静态语句块中的语句合并而成的，编译器收集的顺序是由语句在
   源文件中出现的顺序决定的。
   * <clinit>()方法与类的实例构造器<init>()方法不同，不会显式地调用父类构造器，但是JVM会保证在调用子类的<clinit>()方法
   执行之前，父类的<clinit>()方法已经执行完毕。所以父类中定义的静态语句块优先于子类的变量赋值操作。
   > 注意一点，JVM会保证多线程在进行类初始化的时候，会加锁保证只有一个线程可以操作，所以如果在<clinit>()方法中有耗时很长
    的操作，可能就会造成多个线程阻塞，这种情形比较隐蔽。
    类什么时候会被初始化？
    * new 一个类的时候
    * 访问一个类的静态变量或静态方法的时候
    * 反射触发类的方法获取值的时候
    * 作为Java的启动类启动的时候

3. JVM中有哪些类加载器？
    对JVM来说，只有两种类加载器，一种是类启动加载器(bootstrap classloader),由c++实现，是JVM自身的一部分。另一种就是其他类的
    加载器，由java语言实现，继承于ClassLoader类。
    启动类加载器加载java_home/lib下面的类。
    其他类可以分为扩展类加载器和应用程序类加载器。
    扩展类加载器加载java_home/ext下面的类。
    应用程序加载器加载classpath下面的类，如果应用程序中没有自定义的类加载器，这个就是默认的类加载器。

4. 讲一下你理解的双亲委派模型？
    双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都要有自己的父类加载器。不一定使用继承，可以使用组合方式。
    它的工作过程是：如果一个类加载器收到了加载类的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给自己的父类
    加载器去完成，每一个层次的类加载器都是如此，一直传到顶层的启动类加载器，如果当父类加载器反馈自己无法完成这个加载请求（
    在自己的搜索范围内没有找到所需的类）时，子类加载器才会加载。
    它有助于Java程序的稳定，Java类会因它的类加载器而存在一种优先级的关系。Object类就在顶层，不会被Application类加载器加载。
    不会扰乱整个类型体系。实现双亲委派模型的代码是在ClassLoader类的loadClass()中实现的。

5. 线程上下文类加载器对双亲委派模型有什么影响？
   它在一定程序上破坏了双亲派模型，但对于JNDI,JDBC等情况下，又需要它。
   它可以通过Thread类的setContextClassLoader()方法来进行设置，如果线程创建时还没未设置，它将会从父线程中继承，如果全局范围内
   没有设置过，那就是ApplicationClassLoader.
   SPI(SERVICE PROVIDER INTERFACE)

6. Class.forName和ClassLoader.loadClass()有什么区别？
   Class.forName加载类后对类进行了初始化操作，而后者装载类之后没有进行链接。
   如果程序依赖类的初始化，则需要使用Class.forName。