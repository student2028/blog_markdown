---
title: Java集合面试题1
date: 2021-07-11
comments: true #是否可评论
toc: true #是否显示文章目录
categories: "面试题" #分类
tags:   #标签
    - JAVA
    - 面试题
---

#### hashmap需要扩容的时候会影响性能，为什么不一开始给一个大的初始化值呢？
    因为它迭代的性能取决于hashmap的size和元素的数量，如果初始值设得过大，
    则在它上面的迭代就会性能很差。
    同样的道理，load factor也不能设得太低，太低就会更早地扩容。

#### Java8的hashmap中使用了红黑树，为什么链表超过8个长度并且整个容量大于64的时候转成树呢？
     假定数据的key的hashcode符合泊松分布，超过8个长度的时候，
     是小于千万分之一的概率。如果达到，说明数据有严重的分布问题。
     以防性能太差，就转成红黑树，至少可以保证logn的读写性能。
     容量太小，转成树反而还没有链表的查询快。转换构造树的时间也很耗时。 

#### Java8中HashMap为什么容量大小必须是2的N次方呢？
     算对象所在hashmap中的位置是这么做的，(h=key.hashcode()) ^ (h>>>16) ，即使用了key生成的hashcode的高位右位十六位再和
     原来的hashcode进行计算，这样让高位也参与了运算，这样的扰动函数，降低了碰撞的机会。
     通过把容量保持在2的N次次，我们在扩容后，Node的新的位置要么在旧的位置要么是旧的容量+旧的位置，这样hash就不用算了。只需要一个
     判断就可以，提高了效率。(e.hash & oldCap) == 0, 如果hash和旧的容量与之后等于0，则说明e.hash就小于oldCap,则不变。否则
     新的位置就是旧的位置加oldCap。
     扩容的时候只移动大约一半的数据，并且不会造成扩容之后碰撞更加严重的情况
     例如: hash值为4和8的值存放在size为4的数组中，则两个元素都存放在0下标的数据中，当以2倍扩容时，size变为8，
     8存放在0下标位置上，而4移动到下标为4的位置上(4+0)，这样不仅达到了扩容的效果，还减少了hash碰撞，一举两得。
     在hashTable中求元素位置的时候使用的方式 (n-1) & hash的方式等价于取余，但是效率更高，这要求length是2的N次方。

#### HashMap是不是线程安全的？多线程的时候它可能会出现什么问题?
     它的put,resize方法都不是线程安全的。
     多线程的时候可能会出现并发修改异常或者丢失数据等问题。
     一个在循环迭代，一个删除元素会引发并发修改异常，如果两个线程同时插入一个hashcode相同的元素，在插入的时候可能会丢失。java8中
     使用在链表尾部插入元素。
     jdk1.7中在resize中因为transfer的时候逆转链表可能引起链表成环，读取的时候死循环的问题在1.8中解决了，1.8不对链表逆转。

     如何让它变成线程安全的呢？
     1. 在创建的时候把它转成线程安全的，使用Collections.SynchronizedMap(m)的方式。它的原理是什么呢？
     2. 使用JUC中的ConcurrentHashMap来替换它。
     3. 用hashtable
     4. 自己使用synchronized的关键字。

#### 请一下ConcurrentHashMap的原理？
    ConcurrentHashMap在1.7中是使用（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，
    多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。
    Java8中使用Node数组+链表 / 红黑树， 利用CAS+Synchronized来保证并发更新的安全，
    底层依然采用数组+链表+红黑树的存储结构。

#### HashSet如何检查重复的？
     首先是使用对象的hashcode进行判断，如果相同，再使用Equals方法进行判断，因为可能存在碰撞，所以还是需要具体的值对比一下。

#### 请一下hashMap的原理？
     JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 
     hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置
     （这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的
      hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。

     所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的
      hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。
     JDK1.8之后引入了红黑树，算hashcode只使用了一次扰支函数，仍是使用(n-1) & hash的方式来判断元素的存储位置。
     保证容量是2的N次方，方便了resize寻找元素的位置。
    